// RPMsg static endpoints

digraph G {
  rankdir="LR";

  subgraph roles {
    node [style="filled", fillcolor="lightblue"];
    master [label="Master"];
    slave [label="Slave"];
  }

  subgraph m_comment_nodes {
    node [group=m_comment, shape="note", style="filled", fillcolor="yellow"];
    rank="same";
    m_rproc_init_comment [label="this is initialize rproc call"];
    m_rproc_boot_comment [label="it will setup vdev before booting the remote"];
    m_rpmsg_vdev_init_comment [label="\l* It will initialize vrings with the shared memory\l* As vdev doesn't support name service, it will not create name service endpoint;\l* it sets vdev status to DRVIER_READY, And will notify remote.\l"];
    m_rpmsg_create_ep_comment [label="\lAs vdev doesn't supports name service,\lit will not send out name service.\l"];
  }

  subgraph m_flow_nodes {
    node [shape="box"];
    rank="same";
    m_rproc_init [label="rproc = rproc_init(&rproc_ops, &config_data);"];
    m_rproc_load_fw [label="calls rproc_load_fw() to load firmware"];
    m_rproc_boot [shape="box", label="ret=rproc_boot(&rproc)"];
    m_rproc_get_vdev [label="vdev=rproc_get_vdev_by_id(rproc, rpmsg_vdev_id);"];
    m_rpmsg_vdev_init [label="rpdev=rpmsg_vdev_init(vdev,&shm,&shm_io);"];
    m_rpmsg_create_ep [label="\lept=rpmsg_create_endpoint(vdev, ept_name, ept_addr, dest_addr, \lendpoint_cb, destroyed_cb);\l"];
    m_rpmsg_send [label="rpmsg_send(ept,data)"];
    m_rpmsg_rx_cb [label="rpmsg_rx_callback()"];
    m_ep_cb [label="endpoint_cb(ept, data, size, src_addr)"];
    m_rpmsg_destroy_ep [label="rpmsg_destroy_endpoint(ept)"];

    m_rproc_init -> m_rproc_load_fw -> m_rproc_boot -> m_rproc_get_vdev ->
    m_rpmsg_vdev_init -> m_rpmsg_create_ep -> m_rpmsg_send;
    m_rpmsg_send -> m_rpmsg_rx_cb -> m_ep_cb ->
    m_rpmsg_destroy_ep [dir="none", style="dashed"];
  }

  subgraph s_flow_nodes {
    rank="same";
    node [shape="box"];
    s_rproc_init [label="rproc = rproc_init(&rproc_ops, &config_data);"];

    s_rproc_parse_rsc [label="ret = rproc_parse_rsc(rproc, &rsc_table, slave)"];
    s_rproc_get_vdev [label="vdev=rproc_get_vdev_by_id(rproc, rpmsg_vdev_id);"];
    s_rpmsg_vdev_init [label="rpdev=rpmsg_vdev_init(vdev, NULL, &shm_io);"];
    s_rpmsg_create_ep [label="\lept=rpmsg_create_endpoint(vdev, ept_name, ept_addr, dest_addr, \lendpoint_cb, destroyed_cb);\l"];
    s_rpmsg_send [label="rpmsg_send(ept,data)"];
    s_rpmsg_rx_cb [label="rpmsg_rx_callback()"];
    s_ep_cb [label="endpoint_cb(ept, data, size, src_addr)"];
    s_rpmsg_destroy_ep [label="rpmsg_destroy_endpoint(ept)"];

    s_rproc_init -> s_rproc_parse_rsc -> s_rproc_get_vdev ->
    s_rpmsg_vdev_init -> s_rpmsg_create_ep;
    s_rpmsg_create_ep -> s_rpmsg_rx_cb ->
    s_ep_cb -> s_rpmsg_send -> s_rpmsg_destroy_ep [dir="none", style="dash"];

  }

  subgraph s_comment_nodes {
    node [group=s_comment, shape="note", style="filled", fillcolor="yellow"];
    rank="same";
    s_rpmsg_vdev_init_comment [label="\l* As vdev doesn't support name service, it will not create name service endpoint;\l* It will not return until the master set status to DRIVER READY\l"];
    s_rpmsg_rx_cb_comment [label="\l* It will look for the endpoint which matches the destination address.\lIf no endpoint has found, it will drop the message.\l"];
  }

  master -> m_rproc_init [dir="none"];
  slave -> s_rproc_init [dir="none"];
  m_rpmsg_send -> s_rpmsg_rx_cb [label="RPMsg data"];
  s_rpmsg_send -> m_rpmsg_rx_cb [label="RPMsg data"];

  m_rproc_init_comment -> m_rproc_init [dir="none"];
  m_rproc_boot_comment -> m_rproc_boot [dir="none"];
  m_rpmsg_vdev_init_comment -> m_rpmsg_vdev_init [dir="none"];
  m_rpmsg_create_ep_comment -> m_rpmsg_create_ep [dir="none"];

  s_rpmsg_vdev_init -> s_rpmsg_vdev_init_comment [dir="none"];
  s_rpmsg_rx_cb -> s_rpmsg_rx_cb_comment [dir="none"];

  {rank=same; master; m_rproc_init}
  {rank=same; slave; s_rproc_init}

}

