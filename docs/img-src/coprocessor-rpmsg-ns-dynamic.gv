// RPMsg dynamic endpoint creation

digraph G {
  rankdir="LR";

  subgraph roles {
    node [style="filled", fillcolor="lightblue"];
    master [label="Master"];
    slave [label="Slave"];
  }

  subgraph m_comment_nodes {
    node [group=m_comment, shape="note", style="filled", fillcolor="yellow"];
    rank="same";
    m_rproc_init_comment [label="this is initialize rproc call"];
    m_rproc_boot_comment [label="it will setup vdev before booting the remote"];
    m_rpmsg_vdev_init_comment [label="\l* It will initialize vrings with the shared memory\l* If vdev supports name service, it will create name service endpoint;\l* it sets vdev status to DRVIER_READY, And will notify remote.\l"];
    m_rpmsg_create_ep_comment [label="\if vdev supports name service,\lit will send out name service.\l"];
    m_rpmsg_send_comment [label="\lIf endpoint hasn't binded, it fail\lreturn failure to indicate ep hasn't been binded.\l"];

  }

  subgraph m_flow_nodes {
    node [shape="box"];
    rank="same";
    m_rproc_init [label="rproc = rproc_init(&rproc_ops, &config_data);"];
    m_rproc_load_fw [label="calls rproc_load_fw() to load firmware"];
    m_rproc_boot [shape="box", label="ret=rproc_boot(&rproc)"];
    m_rproc_get_vdev [label="vdev=rproc_get_vdev_by_id(rproc, rpmsg_vdev_id);"];
    m_rpmsg_vdev_init [label="rpdev=rpmsg_vdev_init(vdev,&shm,&shm_io,NULL);"];
    m_rpmsg_ns_cb [label="\lrpmsg_ns_callback() will see if there is a local ep registered.\lIf yes, bind the ep; otherwise, stores the remote ep info.\l"];
    m_rpmsg_create_ep [label="\lept=rpmsg_create_endpoint(vdev, ept_name, ept_addr, ANY_ADDR,\lendpoint_cb, destroyed_cb);\l"];
    m_rpmsg_send [label="rpmsg_send(ept,data)"];
    m_rpmsg_rx_cb [label="rpmsg_rx_callback()"];
    m_ep_cb [label="endpoint_cb(ept, data, size, src_addr)"];
    m_rpmsg_destroy_ep [label="rpmsg_destroy_endpoint(ept)"];

    m_rproc_init -> m_rproc_load_fw -> m_rproc_boot -> m_rproc_get_vdev ->
    m_rpmsg_vdev_init -> m_rpmsg_create_ep -> m_rpmsg_ns_cb -> m_rpmsg_send;
    m_rpmsg_send -> m_rpmsg_rx_cb -> m_ep_cb ->
    m_rpmsg_destroy_ep [dir="none", style="dashed"];
  }

  subgraph s_flow_nodes {
    rank="same";
    node [shape="box"];
    s_rproc_init [label="rproc = rproc_init(&rproc_ops, &config_data);"];

    s_rproc_parse_rsc [label="ret = rproc_parse_rsc(rproc, &rsc_table, slave)"];
    s_rproc_get_vdev [label="vdev=rproc_get_vdev_by_id(rproc, rpmsg_vdev_id);"];
    s_rpmsg_vdev_init [label="rpdev=rpmsg_vdev_init(vdev, NULL, &shm_io, ns_no_ep_found_cb);"];
    s_rpmsg_ns_cb [label="\lrpmsg_ns_callback() will see if there is a local ep registered.\lIf yes, bind the ep; otherwise, it will call ns_no_ep_found_cb().\lIf the callback doesn't return created endpoint, it will store the ns info."];
    s_rpmsg_no_ep_found_cb [label="s_rpsmg_ns_no_ep_found_cb(ept_name, src_ept_addr)"];
    s_rpmsg_create_ep [label="\lept=rpmsg_create_endpoint(vdev, ept_name, ept_addr, ANY_ADDR,\lendpoint_cb, destroyed_cb);\l"];
    s_rpmsg_send [label="rpmsg_send(ept,data)"];
    s_rpmsg_rx_cb [label="rpmsg_rx_callback()"];
    s_ep_cb [label="endpoint_cb(ept, data, size, src_addr)"];
    s_rpmsg_ns_cb_destroy [label="\lrpmsg_ns_callback() will call the previous\lregistered endpoint destroyed callback,\land then it will destroyed the endpoint\l"];

    s_rproc_init -> s_rproc_parse_rsc -> s_rproc_get_vdev ->
    s_rpmsg_vdev_init -> s_rpmsg_ns_cb -> s_rpmsg_no_ep_found_cb ->
    s_rpmsg_create_ep;
    s_rpmsg_create_ep-> s_rpmsg_rx_cb -> s_ep_cb -> s_rpmsg_send ->
    s_rpmsg_ns_cb_destroy [dir="none", style="dash"];

  }

  subgraph s_comment_nodes {
    node [group=s_comment, shape="note", style="filled", fillcolor="yellow"];
    rank="same";
    s_rpmsg_vdev_init_comment [label="\l* If vdev supports name service, it will create name service endpoint;\l* It will not return until the master set status to DRIVER READY\l"];
    s_rpmsg_rx_cb_comment [label="\l* It will look for the endpoint which matches the destination address.\lIf the two endpoints hasn't binded yet,\lit will set the local endpoint's destination address with the source address in the message\l"];
  }

  master -> m_rproc_init [dir="none"];
  slave -> s_rproc_init [dir="none"];
  s_rpmsg_create_ep -> m_rpmsg_ns_cb [label="NS annoucement"];
  m_rpmsg_create_ep -> s_rpmsg_ns_cb [label="NS annoucement"];
  m_rpmsg_send -> s_rpmsg_rx_cb [label="RPMsg data"];
  s_rpmsg_send -> m_rpmsg_rx_cb [label="RPMsg data"];
  m_rpmsg_destroy_ep -> s_rpmsg_ns_cb_destroy [label="Endpoint destroy NS"];

  m_rproc_init_comment -> m_rproc_init [dir="none"];
  m_rproc_boot_comment -> m_rproc_boot [dir="none"];
  m_rpmsg_vdev_init_comment -> m_rpmsg_vdev_init [dir="none"];
  m_rpmsg_create_ep_comment -> m_rpmsg_create_ep [dir="none"];
  m_rpmsg_send_comment -> m_rpmsg_send [dir="none"];

  s_rpmsg_vdev_init -> s_rpmsg_vdev_init_comment [dir="none"];
  s_rpmsg_rx_cb -> s_rpmsg_rx_cb_comment [dir="none"];

  {rank=same; master; m_rproc_init}
  {rank=same; slave; s_rproc_init}

}

